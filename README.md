# BricsAI - Intelligent CAD Assistant & Multi-Agent Orchestrator

BricsAI is an advanced, AI-powered multi-agent desktop application designed to orchestrate and execute complex workflow automation directly within **BricsCAD**. By leveraging a "Mixture of Experts" LLM pipeline, the application interprets user intent, programmatically extracts geometric relationships, and natively manipulates CAD layers and entities via COM automation to eliminate repetitive drafting labor.

---

## üöÄ Key Features & UI Dashboard

The standalone BricsAI WPF Overlay floats near the BricsCAD instance, providing a rich, interactive Dashboard for rapid automation.

![BricsAI Architecture Agent Interface](https://kroki.io/mermaid/svg/eNp9ks9OwzAMxu88hbUDfw6DF4BJIStSpZVVdHSHaIestUqgjaskHUPqw5NmYyA2qJREcj9__tlJZWT7AovpGfjv2aK5FMO-uoLxeAI9r1XxZuHiqdPAOkeNdIr0BTzHvV8ikUovlS7p_Xormxpu12YCy_QBUoMWtQvqVfAOm-3WVSg4mpviBa0zQQELhWYUFAEjDsXzJPjnCt8TKnHvzolMqbR0ZFaHjDwJGRkTWWc2-EEGWOXrHykiJqItFr6TvxQ5E7msVSn_lsxmifArQ7NRBe6w5i1qFgNL4295xmB8vdMfYtGJWP4rhro8NbId-DCuc1gQ1fbX2PZ0nAtOjb84j75ji7VDQy0kUssKf4wtTURad5XSX38Ggz7Wr1g4Cy7UUNoRtIaa1tne4x-SOQ_U_RNaqjdo4TFa-NtpGqlLr0z_7eXeqMJyNvUPhQq0dvTT9u5u0vN5Ajcwi7N0OOQHGu95z8UhcUpF1wwtztcD7uqIK9r61zX0wcn3v3W9v48vpE-BKtde)

### UI Components & Functionality

#### **Quick Actions Sidebar**
Pre-programmed shortcuts that instantly inject optimized macro-prompts into the Multi-Agent engine over the chat interface.

- **ü§ñ Run Full AI Proofing**
  - **Functionality:** Initiates the complete standard 6-step Exhibition Proofing sequence.
  - **Under the hood:** Preemptively creates standardized `Expo_` layers, performs targeted block explosions, explicitly migrates `outlines` and objects to their respective final presentation states natively via COM without relying on unreliable LISP geometric selections.
  
- **üßπ Clean Geometry**
  - **Functionality:** A fast-action macro to obliterate drawing garbage.
  - **Under the hood:** Triggers a targeted sequence focusing entirely on running universal `-PURGE` operations and aggressively forcing the deletion of empty vendor layers using the destructive `-LAYDEL` command.

- **üìä Generate Summary**
  - **Functionality:** A safe, read-only audit mechanism.
  - **Under the hood:** Commands the Executor Agent *not* to manipulate the drawing. Given the raw Surveyor data, it simply reads back a generated Bill of Materials or object count summary, enabling you to inspect drawings without risking geometric corruption.

#### **Chat Feed & Input Area**
- **Chat Window:** Displays the real-time reasoning logs as the request cascades from the *Surveyor* -> *Executor* -> *Validator* agents.
- **Input Text Box:** A standard natural language input field where ad-hoc tasks or complex logical operations (e.g., "Find the largest box and move it to Layer Frame") can be requested outside the Quick Actions.

---

## ü§ñ Meet the AI Agents (How it Works)

BricsAI doesn't just use one AI; it uses a team of three specialized virtual assistants that talk to each other to make sure your drawing is handled safely and perfectly.

![Diagram](https://kroki.io/mermaid/svg/eNqFkc1KAzEUhfd9igtuKlisluJYS6F_guCqUytSXKSZm05onJQkYy3MwhcoorhRF-LORxB8G1_APoJppn8WxCyGZHLvd849YUKOaEiUgdNWBuw606iy3enr_fvX7WT6-vAJFzK-3IZcrpLUBacDqMXGyCgB39W7j457fUWGIbRDhJriVFdPoI3kyt36Fvc4AT9W1ziWCqp9jEy5pyplXmkhCTQY29ZQZMSjfnmXVy6dmo-RvRJkjAoCYkgCze7X89P3xx00b5DGZgN1rrjBlFWXATqQ02-u4Ww9KmIwAGprktRsvdroZhe77bRpcVzrRafKZQRC9hPo2LFe3mZ2OkRw63DDTz1EOkj9nEs1WPmxsFV0HSfQwqFURtuMKEWtd48JF7Gy_mbPkXGFVBCtG8hs2PMcGReitIV7rMhwRxslB1jayu97XrA3P-ZGPDBhaX94c_SbgYsAUwZjrID5JYMVD2g-_x_jejn13IjHini4hBQ8Dwv0D8iKBP5yoDW-fbOFxfW_nZXo0Q8eCOrt)

### 1. üîç The Surveyor (The Eyes)
Before BricsAI touches anything, the **Surveyor** looks at your current drawing. It reads all the invisible data‚Äîlike what layers exist and where your bounding boxes are. It then translates that raw CAD data into plain English (e.g., *"I see 45 booth outlines on a layer called 'outlines'"*) so the rest of the team understands what they are working with.

### 2. ‚öôÔ∏è The Executor (The Hands)
The **Executor** is the workhorse. It takes your request (e.g., "Clean the geometry") and pairs it with the Surveyor's report. It then acts like a master programmer, instantly writing a massive list of highly specific CAD commands, targeting the exact layers the Surveyor found, and fires them directly into BricsCAD.

### 3. üõ°Ô∏è The Validator (The QA Manager)
Once BricsCAD finishes running the Executor's code, the **Validator** steps in. It reviews the deep logs generated by BricsCAD to verify that the Executor *actually* did what you asked it to do. If a layer failed to delete or a selection missed, the Validator catches it and reports back to you in the chat!

---

## üèóÔ∏è Technical Architecture (HLD)

The solution operates as a decoupled architecture consisting of a standalone WPF Desktop application running outside the CAD process, communicating directly with BricsCAD via Microsoft Windows Component Object Model (COM) interoperability. 

### Sequence Diagram
The automation pipeline relies on multiple distinct AI agents to maximize reliability.

![Diagram](https://kroki.io/mermaid/svg/eNqFVE2TEjEQvfsr-shW7cedsqjCwbWwFlbB5WJ56M30DtGQxCSA491_4a_zl9hJZgZ2B5QLw6Tf636vX_D0fUta0ERi5XDzCvhj0QUppEUd4MGT670sjHGl1BiMA_TwMIUbmKHUK0n7mSlJ9RDLrdtRncu753FFfDQYTy969W9_kNg29N3zP-oLsymUjMcMeOOk8MV4AsX9DKY6kDO2h1ihkmWr4PDjqEeCRP1Xo9GR4iFwJ_HNw8ctf8FYBGk0MDTUljxI7qdDwh6BEkUz4hAW0XQfYOJwL3UFy4CBGkhTdPWy6QL3uQ4mGBAGd1iT85dAQVxnP070bK0ewlijqn9SYhj7WotBeszIuWFasyMHB0DyzToKHnhKiHaq2BI0bsi_fnQjVmpAmUoKVOBpw65KAcJwmmzw14m55evJWbb1XRoWZI0L55S0IRjCO9LkePQZCmd81pKxl2loHV6KOmDZXrsNvCVKr-LiLIa1B9QlVA1xEoewQe_ljuD98n4O6BzWYJ4gGKOABatGYMvdE_g5A5t4fFCo4cs5cUfRyHyUYVlcxGZJyhgLt-wVoVgfRklnz9PzjHOOgYWoGgpHMUCf0FUUICfoJLi9QXFPuuQTXlY5uIgpN49frxOSDbKW05sIuOo_-Z1QQKmobBRGU-5M5c9Z0t3IYXs5qQNmWyI629LV9pr--f0LVuTkE2c074GXyjPcwG0a5kTjeOF5Wuktx51D6bcq8KWOf3LFGsNfQPe-QQ==)

---

## üß© Key Technical Implementations

1. **Native COM Layer Migration (`NET:SELECT_LAYER:<source>:<target>`):**
   - The application bypasses unreliable LISP `ssget` selections which risk "bleed-over" between commands.
   - Using the custom tool structure, the Executor Agent forces the C# host to natively create target layers implicitly and assign objects programmatically ($Area$ boundaries, $LWPOLYLINE$ closure checks, and direct `.Layer` assignments).

2. **Exhaustive Geometry Preparation Pipeline:**
   - The `NET:PREPARE_GEOMETRY` tool forces a proactive 30-pass recursive mathematical blast over all objects in a drawing. It explicitly targets complex and 3D geometry (Dimensions, Hatches, Splines, Polyface Meshes) while protecting 2D primitive boundaries via a strict whitelist filter (`Arc`, `Line`, `Circle`, `Ellipse`, `LWPolyline`, `Solid`, `Text`).
   - All legacy non-explodable entities are instantly swept and explicit vendor booth layers are automatically locked before the sequence begins to preserve geometric integrity.

3. **Defensive LISP Execution Runtime:**
   - The Agent system prompt strictly forbids bare `ssget` queries, aggressively forcing the LLM to wrap all `(command)` executions in defensive `(if (setq ss (ssget...)))` LISP blocks to guarantee the BricsCAD COM engine never deadlocks or hangs waiting for mouse input on empty queries.

4. **Pluggable Capabilities Architecture:**
   - Instead of monolithic updates to the AI's core capabilities, tools are implemented via the `IToolPlugin` interface (e.g. `LayerToolsPlugin.cs` and `GeometryToolsPlugin.cs`).
   - The `PluginManager` dynamically reads the user's active BricsCAD version (V15 vs V19) via COM reflection and loads the correct compiled .NET DLL execution binary on the fly.

5. **Live Chat Telemetry Stream:**
   - Instead of locking the WPF interface while the background Agent script runs, BricsAI utilizes an `IProgress<string>` asynchronous callback stream. Users can watch the AI's step-by-step progress, LISP errors, and `NET:MESSAGE:` returns populate directly in the active chat bubble line-by-line in real time.

6. **Persistent Configurable Layer Mappings:**
   - To handle unpredictable layer naming conventions from external vendors, BricsAI reads a `layer_mappings.json` configuration file dynamically at runtime.
   - The Surveyor and Executor agents natively prioritize these explicit mappings (e.g., mapping `"l1xxxx"` to `"Expo_BoothOutline"`) over geometric guesswork for precision reliability.

![Diagram](https://kroki.io/mermaid/svg/eNpLy8kvT85ILCpRCHHhUgCC0OLUIo3oD_MnrnjU0Pth_qTdYJFYTQVdXbsa15TMkuIaBa9gf7_onMTK1KL43MSCgsy89GK9rOL8vFiwCSBZsGqf_MSU1BSFpMoahVDPaLBZ4QFuCv5FyRmpxSVFiSX5RRAdoZ5g9Z55WanJJcUKzvl5JakVJTUKwaVFZamV-UVAvVN64TwFx_TUvBL8Ol0rUpNLgeZHP5o18_2OfjgfWS_cPF09oBEBRZn5RZklmVWpxQq-UE8hzAFrgBsCDgowB6jYJbMIaLeCc2Ix0F6noszkYmdHl2gNGEvBBxROxZoQO8FEcUllTiokmNIyc3KslNMs04zSTHSAYZKfnWqlnGxuZGqSCgDh65BX)

---

## üõ†Ô∏è Setup & Configuration

### Prerequisites
- BricsCAD (V15 or newer recommended).
- .NET 9.0 SDK installed on the workstation.
- An Active OpenAI API Key.

### Running the Application
1. Configure `BricsAI.Overlay/appsettings.json` with your OpenAI Key.
2. Build the `BricsAI.sln` project via Visual Studio or `build.bat`.
3. Launch BricsCAD manually.
4. Run `BricsAI.Overlay.exe` to spawn the multi-agent UI overlay over BricsCAD.
